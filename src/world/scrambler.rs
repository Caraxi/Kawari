//! Obfuscation-related structures and procedures. This is based on the ever fantastic work of Perchbird and his Unscrambler: https://github.com/perchbirdd/Unscrambler
//! This is simply a Rust-reimplementation of Unscrambler.

/// Constant to enable packet obfuscation. Changes every patch.
pub const OBFUSCATION_ENABLED_MODE: u8 = 118;

/// Generates the necessary keys from three seeds.
pub struct ScramblerKeyGenerator {
    table0: &'static [i32],
    table1: &'static [i32],
    table2: &'static [i32],
    mid_table: &'static [u8],
    day_table: &'static [u8],
    table_radixes: &'static [i32],
    table_max: &'static [i32],
}

impl ScramblerKeyGenerator {
    pub fn new() -> Self {
        // Technically unsafe, but Unscrambler's tables should be correct anyway
        unsafe {
            Self {
                table0: std::mem::transmute::<&[u8], &[i32]>(include_bytes!(
                    "../../resources/table0.bin"
                )),
                table1: std::mem::transmute::<&[u8], &[i32]>(include_bytes!(
                    "../../resources/table1.bin"
                )),
                table2: std::mem::transmute::<&[u8], &[i32]>(include_bytes!(
                    "../../resources/table2.bin"
                )),
                mid_table: include_bytes!("../../resources/midtable.bin"),
                day_table: include_bytes!("../../resources/daytable.bin"),

                // TODO: is it possible to calculate these automatically?
                table_radixes: &[93, 94, 113],
                table_max: &[219, 187, 113],
            }
        }
    }

    fn derive(&self, set: u8, n_seed_1: u8, n_seed_2: u8, epoch: u32) -> u8 {
        // FIXME: so many probably unnecessary casts here

        let mid_index = 8 * (n_seed_1 as usize % (self.mid_table.len() / 8));
        let mid_table_value = self.mid_table[4 + mid_index];
        let mut mid_bytes = [0u8; 4];
        mid_bytes.copy_from_slice(&self.mid_table[mid_index..mid_index + 4]);
        let mid_value = u32::from_le_bytes(mid_bytes);

        let epoch_days = 3 * (epoch as usize / 60 / 60 / 24);
        let day_table_index = 4 * (epoch_days % (self.day_table.len() / 4));
        let day_table_value = self.day_table[day_table_index];

        let set_radix = self.table_radixes[set as usize];
        let set_max = self.table_max[set as usize];
        let table_index = (set_radix as i32 * (n_seed_2 as i32 % set_max as i32)) as usize
            + mid_value as usize * n_seed_1 as usize % set_radix as usize;
        let set_result = match set {
            0 => self.table0[table_index],
            1 => self.table1[table_index],
            2 => self.table2[table_index],
            _ => 0,
        };

        (n_seed_1 as i32 + mid_table_value as i32 + day_table_value as i32 + set_result) as u8
    }

    /// Generates keys for scrambling or unscrambling packets. The callee must keep track of their seeds, we only generate the keys.
    pub fn generate(&self, seed1: u8, seed2: u8, seed3: u32) -> ScramblerKeys {
        let neg_seed_1 = seed1;
        let neg_seed_2 = seed2;
        let neg_seed_3 = seed3;

        ScramblerKeys {
            keys: [
                self.derive(0, neg_seed_1, neg_seed_2, neg_seed_3),
                self.derive(1, neg_seed_1, neg_seed_2, neg_seed_3),
                self.derive(2, neg_seed_1, neg_seed_2, neg_seed_3),
            ],
        }
    }
}

/// Holds the keys generated by `ScramblerKeyGenerator`.
#[derive(Debug, Clone)]
pub struct ScramblerKeys {
    keys: [u8; 3],
}

impl ScramblerKeys {
    /// Fetches the required base key for the given opcode.
    pub fn get_base_key(&self, opcode: u16) -> u8 {
        self.keys[(opcode % 3) as usize]
    }
}
